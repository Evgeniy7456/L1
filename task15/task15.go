package main

/*
Задание 15

К каким негативным последствиям может привести данный фрагмент кода, и как это исправить? Приведите корректный пример реализации.

var justString string

func someFunc() {
	v := createHugeString(1 << 10)
	justString = v[:100]
}

func main() {
	someFunc()
}
*/

// Использовать глобальную переменную для сохранения результатов выполнения функции не лучшее решение. Это не позволит
// использовать функцию повторно. Лучше, чтобы функция возвращала результат. Тогда при каждом вызове функции результат
// можно сохранять в разные переменные.

// Также можно не использовать допольнительную переменную для сохранения результата вызова другой функции, а возвращать
// сразу срез этого результата.

// func someFunc() string {
// 	return createHugeString(1 << 10)[:100]
// }

// func main() {
// 	justString := someFunc()
// }

// Если понадобится срез другой длины, то данную функцию применить не получится. Чтобы это исправить нужно добавить
// параметр.

// func someFunc(N int) string {
// 	return createHugeString(1 << 10)[:N]
// }

// func main() {
// 	justString := someFunc(100)
// }

// Нет подробностей о работе функции createHugeString.

// Может ли эта функция сразу вернуть строку необходимой длины?
// Если может, тогда необходимую длину строку нужно передать в качестве параметра.

// func someFunc(N int) string {
// 	return createHugeString(N)
// }

// Если это невозможно, но при этом createHugeString принимает параметр, то чтобы сделать функцию someFunc еще более
// гибкой, нужно добавить параметр для функции createHugeString.

// func someFunc(H int, N int) string {
// 	return createHugeString(H)[:N]
// }

// func main() {
// 	justString := someFunc(1 << 10, 100)
// }

func main() {

}
